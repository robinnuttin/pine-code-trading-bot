PINE SCRIPT COLLECTION - 13 INDICATORS FOR ULTIMATE COMBINATION
================================================================

1. SUPERTREND [everget]
------------------------
//@version=6
// Copyright (c) 2019-present, Alex Orekhov (everget)
// SuperTrend script may be freely distributed under the terms of the GPL-3.0 license.
indicator('SuperTrend', overlay = true)

const string calcGroup = 'Calculation'
length = input.int(22, title = 'ATR Period', group = calcGroup)
mult = input.float(3, step = 0.1, title = 'ATR Multiplier', group = calcGroup)
src = input.source(hl2, title = 'Source', group = calcGroup)
wicks = input.bool(true, title = 'Take Wicks into Account', group = calcGroup)

const string visualGroup = 'Visuals'
showLabels = input.bool(true, title = 'Show Buy/Sell Labels', group = visualGroup)
highlightState = input.bool(true, title = 'Highlight State', group = visualGroup)

//---

atr = mult * ta.atr(length)

highPrice = wicks ? high : close
lowPrice = wicks ? low : close
doji4price = open == close and open == low and open == high

longStop = src - atr
longStopPrev = nz(longStop[1], longStop)

if longStop > 0
    if doji4price
        longStop := longStopPrev
        longStop
    else
        longStop := lowPrice[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop
        longStop
else
    longStop := longStopPrev
    longStop

shortStop = src + atr
shortStopPrev = nz(shortStop[1], shortStop)

if shortStop > 0
    if doji4price
        shortStop := shortStopPrev
        shortStop
    else
        shortStop := highPrice[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
        shortStop
else
    shortStop := shortStopPrev
    shortStop

var int dir = 1
dir := dir == -1 and highPrice > shortStopPrev ? 1 : dir == 1 and lowPrice < longStopPrev ? -1 : dir

const color textColor = color.white
const color longColor = color.green
const color shortColor = color.red
const color longFillColor = color.new(color.green, 85)
const color shortFillColor = color.new(color.red, 85)

longStopPlot = plot(dir == 1 ? longStop : na, title = 'Long Stop', style = plot.style_linebr, linewidth = 2, color = longColor)
buySignal = dir == 1 and dir[1] == -1
plotshape(buySignal ? longStop : na, title = 'Long Stop Start', location = location.absolute, style = shape.circle, size = size.tiny, color = longColor)
plotshape(buySignal and showLabels ? longStop : na, title = 'Buy Label', text = 'Buy', location = location.absolute, style = shape.labelup, size = size.tiny, color = longColor, textcolor = textColor)

shortStopPlot = plot(dir == 1 ? na : shortStop, title = 'Short Stop', style = plot.style_linebr, linewidth = 2, color = shortColor)
sellSignal = dir == -1 and dir[1] == 1
plotshape(sellSignal ? shortStop : na, title = 'Short Stop Start', location = location.absolute, style = shape.circle, size = size.tiny, color = shortColor)
plotshape(sellSignal and showLabels ? shortStop : na, title = 'Sell Label', text = 'Sell', location = location.absolute, style = shape.labeldown, size = size.tiny, color = shortColor, textcolor = textColor)

midPricePlot = plot(ohlc4, title = '', display = display.none, editable = false)

fill(midPricePlot, longStopPlot, title = 'Long State Filling', color = (highlightState and dir == 1 ? longFillColor : na))
fill(midPricePlot, shortStopPlot, title = 'Short State Filling', color = (highlightState and dir == -1 ? shortFillColor : na))

alertcondition(dir != dir[1], title = 'SuperTrend Direction Change', message = 'SuperTrend has changed direction, {{exchange}}:{{ticker}}')
alertcondition(buySignal, title = 'SuperTrend Buy', message = 'SuperTrend Buy, {{exchange}}:{{ticker}}')
alertcondition(sellSignal, title = 'SuperTrend Sell', message = 'SuperTrend Sell, {{exchange}}:{{ticker}}')


2. CHANDELIER EXIT [everget]
-----------------------------
//@version=6
// Copyright (c) 2019-present, Alex Orekhov (everget)
// Chandelier Exit script may be freely distributed under the terms of the GPL-3.0 license.
indicator('Chandelier Exit', shorttitle = 'CE', overlay = true)

const string calcGroup = 'Calculation'
length = input.int(22, title = 'ATR Period', group = calcGroup)
mult = input.float(3.0, step = 0.1, title = 'ATR Multiplier', group = calcGroup)
useClose = input.bool(true, title = 'Use Close Price for Extremums', group = calcGroup)

const string visualGroup = 'Visuals'
showLabels = input.bool(true, title = 'Show Buy/Sell Labels', group = visualGroup)
highlightState = input.bool(true, title = 'Highlight State', group = visualGroup)

const string alertGroup = 'Alerts'
awaitBarConfirmation = input.bool(true, title = 'Await Bar Confirmation', group = alertGroup)

//---

atr = mult * ta.atr(length)

longStop = (useClose ? ta.highest(close, length) : ta.highest(length)) - atr
longStopPrev = nz(longStop[1], longStop)
longStop := close[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop

shortStop = (useClose ? ta.lowest(close, length) : ta.lowest(length)) + atr
shortStopPrev = nz(shortStop[1], shortStop)
shortStop := close[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop

var int dir = 1
dir := close > shortStopPrev ? 1 : close < longStopPrev ? -1 : dir

const color textColor = color.white
const color longColor = color.green
const color shortColor = color.red
const color longFillColor = color.new(color.green, 85)
const color shortFillColor = color.new(color.red, 85)

buySignal = dir == 1 and dir[1] == -1
longStopPlot = plot(dir == 1 ? longStop : na, title = 'Long Stop', style = plot.style_linebr, linewidth = 2, color = longColor)
plotshape(buySignal ? longStop : na, title = 'Long Stop Start', location = location.absolute, style = shape.circle, size = size.tiny, color = longColor)
plotshape(buySignal and showLabels ? longStop : na, title = 'Buy Label', text = 'Buy', location = location.absolute, style = shape.labelup, size = size.tiny, color = longColor, textcolor = textColor)

sellSignal = dir == -1 and dir[1] == 1
shortStopPlot = plot(dir == 1 ? na : shortStop, title = 'Short Stop', style = plot.style_linebr, linewidth = 2, color = shortColor)
plotshape(sellSignal ? shortStop : na, title = 'Short Stop Start', location = location.absolute, style = shape.circle, size = size.tiny, color = shortColor)
plotshape(sellSignal and showLabels ? shortStop : na, title = 'Sell Label', text = 'Sell', location = location.absolute, style = shape.labeldown, size = size.tiny, color = shortColor, textcolor = textColor)

midPricePlot = plot(ohlc4, title = '', display = display.none, editable = false)

fill(midPricePlot, longStopPlot, title = 'Long State Filling', color = (highlightState and dir == 1 ? longFillColor : na))
fill(midPricePlot, shortStopPlot, title = 'Short State Filling', color = (highlightState and dir == -1 ? shortFillColor : na))

await = awaitBarConfirmation ? barstate.isconfirmed : true
alertcondition(dir != dir[1] and await, title = 'CE Direction Change', message = 'Chandelier Exit has changed direction, {{exchange}}:{{ticker}}')
alertcondition(buySignal and await, title = 'CE Buy', message = 'Chandelier Exit Buy, {{exchange}}:{{ticker}}')
alertcondition(sellSignal and await, title = 'CE Sell', message = 'Chandelier Exit Sell, {{exchange}}:{{ticker}}')


3. ANCHORED VWAP BY FIN VIRAJ
------------------------------
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Simple Anchored VWAP with Directional Colors

//@version=6

indicator("Anchored VWAP by Fin Viraj", shorttitle="Anchored VWAP by Fin Viraj", overlay=true)

// === INPUT PARAMETERS ===
anchor_type = input.string("Session", title="Anchor Type",
                          options=["Session", "Day", "Week", "Month", "Manual Date"])
manual_date = input.time(timestamp("2024-01-01"), title="Manual Anchor Date")
reset_anchor = input.bool(false, title="Reset Anchor Point")

// Visual settings
show_bands = input.bool(true, title="Show Standard Deviation Bands")
band_multiplier_1 = input.float(1.0, title="Band 1 Multiplier", step=0.1)
band_multiplier_2 = input.float(2.0, title="Band 2 Multiplier", step=0.1)
line_width = input.int(2, title="VWAP Line Width", minval=1, maxval=4)

// Color settings
bullish_color = input.color(color.new(color.green, 0), title="Bullish Color")
bearish_color = input.color(color.new(color.red, 0), title="Bearish Color")
neutral_color = input.color(color.new(color.blue, 0), title="Neutral Color")
band_color = input.color(color.new(color.gray, 70), title="Band Color")

// === ANCHOR POINT DETECTION ===
is_new_session = ta.change(time("1D")) != 0
is_new_day = ta.change(time("1D")) != 0
is_new_week = ta.change(time("1W")) != 0
is_new_month = ta.change(time("1M")) != 0
is_manual_date = time >= manual_date and time[1] < manual_date

// Determine when to reset anchor
reset_condition = switch anchor_type
    "Session" => is_new_session
    "Day" => is_new_day
    "Week" => is_new_week
    "Month" => is_new_month
    "Manual Date" => is_manual_date
    => false

// Manual reset override
reset_condition := reset_condition or reset_anchor

// === SIMPLE VWAP CALCULATION ===
var float sum_pv = 0.0
var float sum_v = 0.0
var float sum_pv2 = 0.0

// Reset on new anchor
if reset_condition
    sum_pv := 0.0
    sum_v := 0.0
    sum_pv2 := 0.0

// Calculate typical price
typical_price = hlc3
vol = volume

// Accumulate values
sum_pv := sum_pv + (typical_price * vol)
sum_v := sum_v + vol
sum_pv2 := sum_pv2 + (typical_price * typical_price * vol)

// Calculate VWAP
vwap_value = sum_v > 0 ? sum_pv / sum_v : na

// Calculate Standard Deviation
variance = sum_v > 0 ? (sum_pv2 / sum_v) - (vwap_value * vwap_value) : na
std_dev = variance > 0 ? math.sqrt(variance) : na

// === SIMPLE DIRECTIONAL COLORS ===
price_above_vwap = close > vwap_value
price_below_vwap = close < vwap_value
vwap_rising = vwap_value > vwap_value[1]

// Simple color logic
vwap_color = price_above_vwap and vwap_rising ? bullish_color :
             price_below_vwap and not vwap_rising ? bearish_color :
             neutral_color

// === PLOTTING ===
// Main VWAP line
plot(vwap_value, title="Anchored VWAP", color=vwap_color, linewidth=line_width)

// Standard Deviation Bands
upper_band_1 = vwap_value + (std_dev * band_multiplier_1)
lower_band_1 = vwap_value - (std_dev * band_multiplier_1)
upper_band_2 = vwap_value + (std_dev * band_multiplier_2)
lower_band_2 = vwap_value - (std_dev * band_multiplier_2)

upper_1_plot = plot(show_bands ? upper_band_1 : na, title="Upper Band 1", color=band_color)
lower_1_plot = plot(show_bands ? lower_band_1 : na, title="Lower Band 1", color=band_color)
upper_2_plot = plot(show_bands ? upper_band_2 : na, title="Upper Band 2", color=band_color)
lower_2_plot = plot(show_bands ? lower_band_2 : na, title="Lower Band 2", color=band_color)

// Fill between bands
fill_color = color.new(band_color, 90)
fill(upper_1_plot, lower_1_plot, color=fill_color, title="Band Fill")

// === SIMPLE ANCHOR MARKER ===
plotshape(reset_condition, title="New Anchor Point", location=location.bottom,
          style=shape.labelup, size=size.small, color=color.blue, textcolor=color.white,
          text="ANCHOR")


4. VOLUME PROFILE / FIXED RANGE
--------------------------------
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © LonesomeTheBlue

//@version=5
indicator('Volume Profile / Fixed Range', overlay=true, max_boxes_count=200, max_bars_back=501)
bbars = input.int(title='Number of Bars', defval=150, minval=1, maxval=500)
cnum = input.int(title='Row Size', defval=24, minval=5, maxval=100)
percent = input.float(70., title='Value Area Volume %', minval=0, maxval=100)
poc_color = input.color(defval=#ff0000, title='POC Color', inline='poc')
poc_width = input.int(defval=2, title='Width', minval=1, maxval=5, inline='poc')
vup_color = input(defval=color.new(color.blue, 30), title='Value Area Up')
vdown_color = input(defval=color.new(color.orange, 30), title='Value Area Down')
up_color = input(defval=color.new(color.blue, 75), title='UP Volume')
down_color = input(defval=color.new(color.orange, 75), title='Down Volume')
show_poc = input.bool(defval = true, title = "Show POC Label")

top = ta.highest(bbars)
bot = ta.lowest(bbars)
dist = (top - bot) / 500
step = (top - bot) / cnum

// calculate/keep channel levels
levels = array.new_float(cnum + 1)
for x = 0 to cnum by 1
    array.set(levels, x, bot + step * x)

// get the volume if there is intersection
get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)

if barstate.islast
    // calculate/get volume for each channel and candle
    volumes = array.new_float(cnum * 2, 0.)
    for bars = 0 to bbars - 1 by 1
        body_top = math.max(close[bars], open[bars])
        body_bot = math.min(close[bars], open[bars])
        itsgreen = close[bars] >= open[bars]

        topwick = high[bars] - body_top
        bottomwick = body_bot - low[bars]
        body = body_top - body_bot

        bodyvol = body * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        topwickvol = 2 * topwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol = 2 * bottomwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        for x = 0 to cnum - 1 by 1
            array.set(volumes, x, array.get(volumes, x) + (itsgreen ? get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol) : 0) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
            array.set(volumes, x + cnum, array.get(volumes, x + cnum) + (itsgreen ? 0 : get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol)) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)

    totalvols = array.new_float(cnum, 0.)
    for x = 0 to cnum - 1 by 1
        array.set(totalvols, x, array.get(volumes, x) + array.get(volumes, x + cnum))

    int poc = array.indexof(totalvols, array.max(totalvols))

    // calculate value area
    totalmax = array.sum(totalvols) * percent / 100.
    va_total = array.get(totalvols, poc)
    int up = poc
    int down = poc
    for x = 0 to cnum - 1 by 1
        if va_total >= totalmax
            break
        uppervol = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
        lowervol = down > 0 ? array.get(totalvols, down - 1) : 0.
        if uppervol == 0 and lowervol == 0
            break
        if uppervol >= lowervol
            va_total += uppervol
            up += 1
            up
        else
            va_total += lowervol
            down -= 1
            down

    maxvol = array.max(totalvols)
    for x = 0 to cnum * 2 - 1 by 1
        array.set(volumes, x, array.get(volumes, x) * bbars / (3 * maxvol))

    // Draw VP rows
    var vol_bars = array.new_box(cnum * 2, na)
    for x = 0 to cnum - 1 by 1
        box.delete(array.get(vol_bars, x))
        box.delete(array.get(vol_bars, x + cnum))
        array.set(vol_bars, x, box.new(bar_index - bbars + 1,
                                       array.get(levels, x + 1) - dist,
                                       bar_index - bbars + 1 + math.round(array.get(volumes, x)),
                                       array.get(levels, x) + dist,
                                       border_width=0,
                                       bgcolor=x >= down and x <= up ? vup_color : up_color))
        array.set(vol_bars, x + cnum, box.new(bar_index - bbars + 1 + math.round(array.get(volumes, x)),
                                              array.get(levels, x + 1) - dist,
                                              bar_index - bbars + 1 + math.round(array.get(volumes, x)) + math.round(array.get(volumes, x + cnum)),
                                              array.get(levels, x) + dist,
                                              border_width=0,
                                              bgcolor=x >= down and x <= up ? vdown_color : down_color))

    // Draw POC line and label
    poc_level = (array.get(levels, poc) + array.get(levels, poc + 1)) / 2
    var line poc_line = na
    line.delete(poc_line)
    poc_line := line.new(bar_index - bbars + 1, poc_level, bar_index - bbars + 2, poc_level, extend=extend.right, color=poc_color, width=poc_width)
   
    if show_poc
        var label poc_label = na
        label.delete(poc_label)
        poc_label := label.new(bar_index + 15, poc_level,
                               text = "POC: " + str.tostring(math.round_to_mintick(poc_level)),
                               style = close >= poc_level ? label.style_label_up : label.style_label_down)


5. ULTIMATE RSI [LuxAlgo]
-------------------------
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=5
indicator("Ultimate RSI [LuxAlgo]", "LuxAlgo - Ultimate RSI")
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input.int(14, minval = 2)
smoType1 = input.string('RMA', 'Method', options = ['EMA', 'SMA', 'RMA', 'TMA'])
src = input(close, 'Source')

arsiCss = input(color.silver, 'Color', inline = 'rsicss')
autoCss = input(true, 'Auto', inline = 'rsicss')

//Signal Line
smooth = input.int(14, minval = 1, group = 'Signal Line')
smoType2 = input.string('EMA', 'Method', options = ['EMA', 'SMA', 'RMA', 'TMA'], group = 'Signal Line')

signalCss = input(#ff5d00, 'Color', group = 'Signal Line')

//OB/OS Style
obValue = input.float(80, 'Overbought', inline = 'ob', group = 'OB/OS Style')
obCss = input(#089981, '', inline = 'ob', group = 'OB/OS Style')
obAreaCss = input(color.new(#089981, 80), '', inline = 'ob', group = 'OB/OS Style')

osValue = input.float(20, 'Oversold    ', inline = 'os', group = 'OB/OS Style')
osCss = input(#f23645, '', inline = 'os', group = 'OB/OS Style')
osAreaCss = input(color.new(#f23645, 80), '', inline = 'os', group = 'OB/OS Style')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
ma(x, len, maType)=>
    switch maType
        'EMA' => ta.ema(x, len)
        'SMA' => ta.sma(x, len)
        'RMA' => ta.rma(x, len)
        'TMA' => ta.sma(ta.sma(x, len), len)
 
//-----------------------------------------------------------------------------}
//Augmented RSI
//-----------------------------------------------------------------------------{
upper = ta.highest(src, length)
lower = ta.lowest(src, length)
r = upper - lower

d = src - src[1]
diff = upper > upper[1] ? r
  : lower < lower[1] ? -r
  : d

num = ma(diff, length, smoType1)
den = ma(math.abs(diff), length, smoType1)
arsi = num / den * 50 + 50

signal = ma(arsi, smooth, smoType2)

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot_rsi = plot(arsi, 'Ultimate RSI'
  , arsi > obValue ? obCss
  : arsi < osValue ? osCss
  : autoCss ? chart.fg_color : arsiCss)

plot(signal, 'Signal Line', signalCss)

//Levels
plot_up = plot(obValue, color = na, editable = false)
plot_avg = plot(50, color = na, editable = false)
plot_dn = plot(osValue, color = na, editable = false)

//OB-OS
fill(plot_rsi, plot_up, arsi > obValue ? obAreaCss : na)
fill(plot_dn, plot_rsi, arsi < osValue ? osAreaCss : na)

//Gradient
fill(plot_rsi, plot_avg, obValue, 50, obAreaCss, color.new(chart.bg_color, 100))
fill(plot_avg, plot_rsi, 50, osValue, color.new(chart.bg_color, 100), osAreaCss)

hline(obValue, 'Overbought')
hline(50, 'Midline')
hline(osValue, 'Oversold')

//-----------------------------------------------------------------------------}


6. ADAPTIVE MACD [LuxAlgo]
--------------------------
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=5
indicator("Adaptive MACD [LuxAlgo]", "LuxAlgo - Adaptive MACD")
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input.int(20, 'R2 Period', minval = 2)
fast = input.int(10, minval = 2)
slow = input.int(20, minval = 2)
signal = input.int(9, minval = 2)

//-----------------------------------------------------------------------------}
//Ultimate MACD
//-----------------------------------------------------------------------------{
var macd = 0.
var lag  = (signal - 1) / 2
var a1   = 2 / (fast + 1)
var a2   = 2 / (slow + 1)

r2 = .5 * math.pow(ta.correlation(close, bar_index, length), 2) + .5
K = r2 * ((1 - a1) * (1 - a2)) + (1 - r2) * ((1 - a1) / (1 - a2))

macd := (close - close[1]) * (a1 - a2) + (-a2 - a1 + 2) * nz(macd[1]) - K * nz(macd[2])
ema = ta.ema(macd, signal)
hist = macd - ema

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
hist_css = hist > 0 and hist > hist[1] ? #5b9cf6
  : hist > 0 and hist < hist[1] ? color.new(#5b9cf6, 50)
  : hist < 0 and hist < hist[1] ? #f77c80
  : color.new(#f77c80, 50)

plot(hist, 'Histogram', hist_css, 1, plot.style_columns)

plot(macd, 'MACD', chart.fg_color)
plot(ema, 'Signal', #ff5d00)

//-----------------------------------------------------------------------------}


7. ENHANCED ICHIMOKU CLOUD INDICATOR
-------------------------------------
//Created By User ChrisMoody
//Last Update 12-30-2013
//Special Thanks to Alex in Tech Support.  I spent 4 hours and couldn't get it to work and he fixed it in 2 minutes...

study(title="CM_Enhanced_Ichimoku Cloud-V3", shorttitle="CM_Enhanced_Ichimoku-V3", overlay=true)
turningPeriods = input(9, minval=1), standardPeriods = input(26, minval=1)
leadingSpan2Periods = input(52, minval=1), displacement = input(26, minval=1)
donchian(len) => avg(lowest(len), highest(len))
turning = donchian(turningPeriods)
standard = donchian(standardPeriods)
leadingSpan1 = avg(turning, standard)
leadingSpan2 = donchian(leadingSpan2Periods)
 
plot(turning, title = 'Tenkan-Sen (9 Period)', linewidth=4, color=white)
plot(standard, title = 'Kinjun-Sen (26 Period)', linewidth=4, color=orange)
plot(close, title='Chinkou Span (Lagging Line)', linewidth=4, offset = -displacement, color=aqua)
 
spanColor = leadingSpan1>=leadingSpan2 ? lime : red

p1 = plot(leadingSpan1, title = 'Senkou Span A (26 Period)', linewidth=4, offset = displacement, color=spanColor)
p2 = plot(leadingSpan2, title = 'Senkou Span B (52 Period)', linewidth=4, offset = displacement, color=spanColor)
 
fill(p1, p2, color=silver, transp=40, title='Kumo (Cloud)')


8. OBV OSCILLATOR [LazyBear]
----------------------------
//
// @author LazyBear
//
// Appreciate a note if you use this code anywhere.
//
study(title="On Balance Volume Oscillator [LazyBear]", shorttitle="OBVOSC_LB")
src = close
length=input(20)
obv(src) => cum(change(src) > 0 ? volume : change(src) < 0 ? -volume : 0*volume)
os=obv(src)
obv_osc = (os - ema(os,length))
obc_color=obv_osc > 0 ? green : red
plot(obv_osc, color=obc_color, style=line,title="OBV-Points", linewidth=2)
plot(obv_osc, color=silver, transp=70, title="OBV", style=area)
hline(0)


9. SIMPLE BOLLINGER BAND WIDTH PERCENTILE (BBWP)
-------------------------------------------------
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © EltAlt
//@version=5

// I'm a big fan of The_Caretaker's BBWP and wanted to add it as a volatility indicator to some of my scripts, but since it is over
// 100 lines of code (plus spacing and comments) I wanted to find if there was a simpler way to get comparable results. SBBWP uses Pine 5
// built in functions that I don't believe were available when The_Caretaker wrote BBPW. The main limitations compared to The_Caretaker's
// version is that it can only use SMA as its Basis Type and the colors are also not as pretty. I have not included alerts or scale lines
// since I'm not trying to replace BBWP, just give a simple example that you can easily build in to your scripts.
// Full credit and respect to The_Caretaker!

indicator('Simple Bollinger Band Width Percentile', 'SBBWP', overlay=false, format=format.percent, precision=2, max_bars_back = 1000)

i_priceSrc = input.source ( close,   'Price Source',                                 inline='1', group='BBWP Properties')
i_bbwpLen  = input.int    ( 13,      'Length',       minval=1,                       inline='2', group='BBWP Properties')
i_bbwpLkbk = input.int    ( 252,     '     Lookback',  minval=1,                     inline='2', group='BBWP Properties')
i_ma1On    = input.bool   ( true,    '',                                             inline='3', group='BBWP Properties')
i_ma1Type  = input.string ( 'SMA',   'BBWP MA Type', options=['SMA', 'EMA', 'VWMA'], inline='3', group='BBWP Properties')
i_ma1Len   = input.int    ( 5,       'Length',       minval=1,                       inline='3', group='BBWP Properties')

bbwp       = ta.percentrank(ta.bbw(i_priceSrc, i_bbwpLen, 1), i_bbwpLkbk)
c_bbwp     = bbwp >= 50 ? color.from_gradient(bbwp, 50, 100, #0AFF00, #FF2900): color.from_gradient(bbwp, 0, 49, #0000FF, #0AFF00)
bbwpMA1    = i_ma1On ? i_ma1Type == 'VWMA' ? ta.vwma ( bbwp, i_ma1Len ) : i_ma1Type == 'EMA' ? ta.ema ( bbwp, i_ma1Len ) : ta.sma ( bbwp, i_ma1Len ) : na

p_bbwp     = plot ( bbwp,    'BBWP',    c_bbwp,  2, plot.style_line, editable=false )
p_ma1      = plot ( bbwpMA1, 'BBWP MA', #FFFFFF, 1, plot.style_line, 0 )


10. CANDLESTICKS PATTERNS IDENTIFIED
------------------------------------
// Created by Robert N. 030715
// Candle labels
study(title = "Candles", overlay = true)

trend= input(5, minval=1, title="Trend in Bars")

DojiSize = input(0.05, minval=0.01, title="Doji size")
data=(abs(open - close) <= (high - low) * DojiSize)
plotchar(data, title="Doji", text='Doji', color=white)

data6=(close[1] > open[1] and open > close and open <= close[1] and open[1] <= close and open - close < close[1] - open[1] and open[trend] < open)
plotshape(data6, title= "Bearish Harami", color=red, style=shape.arrowdown, text="Bearish\nHarami")

data7=(open[1] > close[1] and close > open and close <= open[1] and close[1] <= open and close - open < open[1] - close[1] and open[trend] > open)
plotshape(data7,  title= "Bullish Harami", location=location.belowbar, color=lime, style=shape.arrowup, text="Bullish\nHarami")

data8=(close[1] > open[1] and open > close and open >= close[1] and open[1] >= close and open - close > close[1] - open[1] and open[trend] < open)
plotshape(data8,  title= "Bearish Engulfing", color=red, style=shape.arrowdown, text="Bearish\nEngulfing")

data9=(open[1] > close[1] and close > open and close >= open[1] and close[1] >= open and close - open > open[1] - close[1] and open[trend] > open)
plotshape(data9, title= "Bullish Engulfing", location=location.belowbar, color=lime, style=shape.arrowup, text="Bullish\nEngulfling")

upper = highest(10)[1]
data10=(close[1] < open[1] and  open < low[1] and close > close[1] + ((open[1] - close[1])/2) and close < open[1] and open[trend] > open)
plotshape(data10, title= "Piercing Line", location=location.belowbar, color=lime, style=shape.arrowup, text="Piercing\nLine")

lower = lowest(10)[1]
data11=(low == open and  open < lower and open < close and close > ((high[1] - low[1]) / 2) + low[1] and open[trend] > open)
plotshape(data11, title= "Bullish Belt", location=location.belowbar, color=lime, style=shape.arrowup, text="Bullish\nBelt")

data12=(open[1]>close[1] and open>=open[1] and close>open and open[trend] > open)
plotshape(data12, title= "Bullish Kicker", location=location.belowbar, color=lime, style=shape.arrowup, text="Bullish\nKicker")

data13=(open[1]<close[1] and open<=open[1] and close<=open and open[trend] < open)
plotshape(data13, title= "Bearish Kicker", color=red, style=shape.arrowdown, text="Bearish\nKicker")


11. RISK CONTEXT + POSITION SIZING
-----------------------------------
//@version=6
indicator("Risk Context + Position Sizing", shorttitle="Risk & Size", overlay=false)

// ===== USER INPUTS ===== //
riskPct = input.float(1.0, "Risk % per Trade", minval=0.1, maxval=5.0, step=0.1, group="Position Sizing")
baseSize = input.float(10000, "Base Position Size", minval=1, group="Position Sizing")
atrLength = input.int(20, "ATR Length", minval=5, maxval=50, group="Risk Calculation")
lookbackPeriod = input.int(100, "Volatility Percentile Lookback", minval=50, maxval=500, group="Risk Calculation")
showTable = input.bool(true, "Show Position Sizing Table", group="Display")
tablePosition = input.string("Middle Right", "Table Position", options=["Top Left", "Top Right", "Middle Left", "Middle Right", "Bottom Left", "Bottom Right"], group="Display")

// ===== VOLATILITY ANALYSIS ===== //
atr = ta.atr(atrLength)
volPercentile = ta.percentrank(atr, lookbackPeriod)

// Dynamic volatility thresholds
atrMedian = ta.median(atr, 200)
atrStdDev = ta.stdev(atr, 200)
highVolThreshold = atrMedian + atrStdDev
lowVolThreshold = math.max(atrMedian - atrStdDev, 0)

// ===== RISK ZONES (DISCRETE) ===== //
getRiskZone() =>
    if volPercentile > 90
        "EXTREME"
    else if volPercentile > 75
        "HIGH"
    else if volPercentile < 25
        "LOW"
    else
        "NORMAL"

riskZone = getRiskZone()

// ===== POSITION SIZING - CONTINUOUS FUNCTIONS ===== //
// Legacy discrete approach (kept for comparison)
getPositionMultiplierDiscrete() =>
    switch
        volPercentile > 90 => 0.4    // Extreme volatility - significantly reduce size
        volPercentile > 75 => 0.7    // High volatility - reduce size
        volPercentile < 15 => 1.4    // Very low volatility - increase size
        volPercentile < 25 => 1.2    // Low volatility - slightly increase size
        => 1.0                       // Normal volatility

// Continuous function - Exponential decay approach
getPositionMultiplierExponential() =>
    // Exponential decay from volatility percentile
    // Formula: multiplier = baseMax * exp(-decay * (volPercentile - centerPoint)^2)
    centerPoint = 30.0  // Sweet spot percentile (low-normal volatility)
    baseMax = 1.25      // Maximum multiplier at center point
    decay = 0.0008      // Controls how fast multiplier decreases
   
    multiplier = baseMax * math.exp(-decay * math.pow(volPercentile - centerPoint, 2))
   
    // Apply minimum floor
    math.max(multiplier, 0.65)

// Continuous function - Inverse polynomial approach  
getPositionMultiplierPolynomial() =>
    // Inverse relationship with volatility percentile
    // More intuitive: higher vol = lower multiplier, lower vol = higher multiplier
   
    // Normalize percentile to 0-1 range
    normalizedVol = volPercentile / 100.0
   
    // Polynomial curve: creates smooth S-curve
    // Formula: multiplier = maxMult - (maxMult - minMult) * vol^power
    maxMultiplier = 1.30
    minMultiplier = 0.70  
    power = 1.8  // Controls curve steepness (higher = more aggressive reduction)
   
    multiplier = maxMultiplier - (maxMultiplier - minMultiplier) * math.pow(normalizedVol, power)
   
    // Ensure bounds
    math.max(math.min(multiplier, maxMultiplier), minMultiplier)

// Continuous function - Logistic (Sigmoid) approach
getPositionMultiplierLogistic() =>
    // Logistic function for smooth transitions
    // Formula: multiplier = minMult + (maxMult - minMult) / (1 + exp(steepness * (volPercentile - midpoint)))
   
    maxMultiplier = 1.25
    minMultiplier = 0.75
    midpoint = 60.0      // Volatility percentile where multiplier = 1.0
    steepness = 0.08     // Controls transition smoothness (lower = smoother)
   
    ranges = maxMultiplier - minMultiplier
    multiplier = minMultiplier + ranges / (1 + math.exp(steepness * (volPercentile - midpoint)))
   
    multiplier

// Choose multiplier based on user preference
functionType = input.string("Logistic", "Position Sizing Function",
     options=["Discrete", "Exponential", "Polynomial", "Logistic"], group="Position Sizing")

positionMultiplier = switch functionType
    "Discrete" => getPositionMultiplierDiscrete()
    "Exponential" => getPositionMultiplierExponential()
    "Polynomial" => getPositionMultiplierPolynomial()
    "Logistic" => getPositionMultiplierLogistic()
    => getPositionMultiplierLogistic()  // Default

// ===== CLEARER RISK CALCULATIONS ===== //
scaledSize = baseSize * positionMultiplier

// Risk calculations with proper labels
dollarRisk = (baseSize * riskPct) / 100           // Actual dollars at risk
percentRisk = riskPct                             // Risk percentage

// Legacy calculation for backward compatibility
riskAmount = scaledSize * riskPct  // This is the old calculation (kept for alerts)

// ===== TABLE DISPLAY ===== //
getTablePosition() =>
    switch tablePosition
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Middle Left" => position.middle_left
        "Middle Right" => position.middle_right
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        => position.middle_right

if barstate.islast and showTable
    var table sizingTable = table.new(getTablePosition(), 2, 8,
         bgcolor=color.new(#1e293b, 85),
         border_width=2,
         border_color=color.new(#475569, 0),
         frame_width=1,
         frame_color=color.new(#64748b, 0))
   
    // Header
    table.cell(sizingTable, 0, 0, "Risk & Position",
         text_color=color.new(#f1f5f9, 0),
         text_size=size.normal,
         bgcolor=color.new(#505050, 0))
    table.cell(sizingTable, 1, 0, "Value",
         text_color=color.new(#f1f5f9, 0),
         text_size=size.normal,
         bgcolor=color.new(#505050, 0))
   
    // Position Size
    table.cell(sizingTable, 0, 1, "Position Size",
         text_color=color.new(#e2e8f0, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
    table.cell(sizingTable, 1, 1, str.tostring(math.round(scaledSize, 1)),
         text_color=color.new(#60a5fa, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
   
    // Size Multiplier
    table.cell(sizingTable, 0, 2, "Size Multiplier",
         text_color=color.new(#e2e8f0, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
    multiplierColor = positionMultiplier > 1 ? color.new(#10b981, 0) :
                     positionMultiplier < 1 ? color.new(#f59e0b, 0) :
                     color.new(#e2e8f0, 0)
    table.cell(sizingTable, 1, 2, str.tostring(positionMultiplier, "#.##") + "x",
         text_color=multiplierColor,
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
   
    // Volatility Percentile
    table.cell(sizingTable, 0, 3, "Volatility %ile",
         text_color=color.new(#e2e8f0, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
    volColor = volPercentile > 75 ? color.new(#ef4444, 0) :
               volPercentile < 25 ? color.new(#10b981, 0) :
               color.new(#e2e8f0, 0)
    table.cell(sizingTable, 1, 3, str.tostring(math.round(volPercentile, 1)) + "%",
         text_color=volColor,
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
   
    // Risk Zone
    table.cell(sizingTable, 0, 4, "Risk Zone",
         text_color=color.new(#e2e8f0, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
    zoneColor = str.contains(riskZone, "HIGH") or riskZone == "EXTREME" ? color.new(#ef4444, 0) : riskZone == "LOW" ? color.new(#10b981, 0) : color.new(#e2e8f0, 0)
    table.cell(sizingTable, 1, 4, riskZone,
         text_color=zoneColor,
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
   
    // Dollar Risk (NEW - clearer calculation)
    table.cell(sizingTable, 0, 5, "Dollar Risk",
         text_color=color.new(#e2e8f0, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
    table.cell(sizingTable, 1, 5, str.tostring(math.round(dollarRisk, 2)),
         text_color=color.new(#f59e0b, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
   
   
    // Function Type (NEW)
    table.cell(sizingTable, 0, 7, "Function",
         text_color=color.new(#e2e8f0, 0),
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))
    functionColor = functionType == "Discrete" ? color.new(#6b7280, 0) : color.new(#10b981, 0)
    table.cell(sizingTable, 1, 7, functionType,
         text_color=functionColor,
         text_size=size.normal,
         bgcolor=color.new(#2d3748, 0))

// ===== CHART VISUALS ===== //
// Volatility percentile plot
plot(volPercentile, "Volatility Percentile", color=color.white)

// Position multiplier plot for comparison (scaled to 0-100 range)
multiplierScaled = (positionMultiplier - 0.2) / (1.5 - 0.2) * 100  // Scale 0.2-1.5 to 0-100
plot(multiplierScaled, "Position Multiplier (Scaled)", color=color.new(color.blue, 30), display = display.none)

// Reference lines
hline(90, "Extreme Vol", color=color.new(#dc2626, 50), linestyle=hline.style_dashed)
hline(75, "High Vol", color=color.new(#ef4444, 0), linestyle=hline.style_solid)
hline(25, "Low Vol", color=color.new(#10b981, 0), linestyle=hline.style_solid)
hline(10, "Very Low Vol", color=color.new(#059669, 50), linestyle=hline.style_dashed)

// Background colors for risk zones
extremeVolBg = volPercentile > 90 ? color.new(#dc2626, 85) : na
highVolBg = volPercentile > 75 and volPercentile <= 85 ? color.new(#ef4444, 90) : na
lowVolBg = volPercentile < 25 ? color.new(#10b981, 85) : na

bgcolor(extremeVolBg, title="Extreme Volatility")
bgcolor(highVolBg, title="High Volatility")
bgcolor(lowVolBg, title="Low Volatility")

// ===== ALERTS ===== //
// Volatility alerts (using legacy riskAmount for backward compatibility)
alertcondition(ta.crossover(volPercentile, 90), "Extreme Volatility Alert", "Volatility percentile crossed above 90% - Consider reducing position sizes significantly")
alertcondition(ta.crossover(volPercentile, 75), "High Volatility Alert", "Volatility percentile crossed above 75% - Consider reducing position sizes")
alertcondition(ta.crossunder(volPercentile, 25), "Low Volatility Alert", "Volatility percentile dropped below 25% - Consider increasing position sizes")
alertcondition(ta.crossunder(volPercentile, 15), "Very Low Volatility Alert", "Volatility percentile dropped below 15% - Low risk environment detected")

// New function change alerts
alertcondition(math.abs(ta.change(positionMultiplier)) > 0.05, "Position Size Change", "Position multiplier changed significantly due to volatility shift")


12. PRICE CLOSE PROBABILITY
----------------------------
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © QuantNomad

//@version=5
indicator("Price Close Probability", shorttitle = "CloseProb", overlay = true)

////////////
// INPUTS /{

level1_name = input.string("Level #1", "#1", inline = "l1", group = "Levels")
level2_name = input.string("Level #2", "#2", inline = "l2", group = "Levels")

level1_price = input.price(0, "", confirm = true, inline = "l1", group = "Levels")
level2_price = input.price(0, "", confirm = true, inline = "l2", group = "Levels")

level1_pos = input.string("Above", "", options = ['Above', 'Below'], inline = "l1", group = "Levels")
level2_pos = input.string("Below", "", options = ['Above', 'Below'], inline = "l2", group = "Levels")

level1_color = input.color(color.red,   "", inline = "l1", group = "Levels")
level2_color = input.color(color.green, "", inline = "l2", group = "Levels")

std_len = input.int(100, "SD Length")

//}

///////////////
// FUNCTIONS /{

cdf(float x, float mean, float stdDev) =>
    float z = (x - mean) / stdDev
    float t = 1 / (1 + 0.2316419 * math.abs(z))
    float d1 = 0.319381530 * t
    float d2 = -0.356563782 * math.pow(t, 2)
    float d3 = 1.781477937 * math.pow(t, 3)
    float d4 = -1.821255978 * math.pow(t, 4)
    float d5 = 1.330274429 * math.pow(t, 5)
    float pdf = math.exp(-0.5 * math.pow(z, 2)) / math.sqrt(2 * math.pi)
    float cdfApprox = 1.0 - pdf * (d1 + d2 + d3 + d4 + d5)
    z < 0 ? 1.0 - cdfApprox : cdfApprox

//}

/////////////////
// CALCULATION /{

std = ta.stdev(close, std_len)

lev1_prob = cdf((level1_pos == 'Below' ? level1_price - close : close - level1_price), 0, std * math.sqrt((time_close - timenow) / (time_close - time)))
lev2_prob = cdf((level2_pos == 'Below' ? level2_price - close : close - level2_price), 0, std * math.sqrt((time_close - timenow) / (time_close - time)))

//}

///////////
// PLOTS /{

plot(level1_price, title = "Level 1", color = level1_color, linewidth = 2)
plot(level2_price, title = "Level 2", color = level2_color, linewidth = 2)

var tbl = table.new(position.bottom_right, 4, 3, frame_width  = 1,
          border_width = 1, border_color = color.new(#696969, 100))

if barstate.islast
    table.clear(tbl, 0, 0, 3, 2)

    table.cell(tbl, 0, 0, 'Level', text_halign = text.align_center, bgcolor = color.gray, text_color = color.white, text_size = size.normal)
    table.cell(tbl, 1, 0, 'Value', text_halign = text.align_center, bgcolor = color.gray, text_color = color.white, text_size = size.normal)
    table.cell(tbl, 2, 0, 'Prob. Cur. Bar', text_halign = text.align_center, bgcolor = color.gray, text_color = color.white, text_size = size.normal)

    table.cell(tbl, 0, 1, level1_name, text_halign = text.align_center, bgcolor = color.gray, text_color = color.white, text_size = size.normal)
    table.cell(tbl, 0, 2, level2_name, text_halign = text.align_center, bgcolor = color.gray, text_color = color.white, text_size = size.normal)

    table.cell(tbl, 1, 1, str.tostring(math.round_to_mintick(level1_price)), text_halign = text.align_center, bgcolor = color.white, text_color = color.black, text_size = size.normal)
    table.cell(tbl, 1, 2, str.tostring(math.round_to_mintick(level2_price)), text_halign = text.align_center, bgcolor = color.white, text_color = color.black, text_size = size.normal)

    table.cell(tbl, 2, 1, str.tostring(math.round(lev1_prob * 100, 2)) + "%", text_halign = text.align_center, bgcolor = color.white, text_color = color.black, text_size = size.normal)
    table.cell(tbl, 2, 2, str.tostring(math.round(lev2_prob * 100, 2)) + "%", text_halign = text.align_center, bgcolor = color.white, text_color = color.black, text_size = size.normal)

//}


13. SIMPLE MOVING AVERAGE x 10
-------------------------------
//@version=4
study(title="Simple Moving Average x 10", shorttitle="SMA x 10", overlay=true, resolution="")

plot(sma(close, 5), color=#ff9800, title="MA 5", offset=0)
plot(sma(close, 10), color=#00c3ff, title="MA 10", offset=0)
plot(sma(close, 20), color=#e652ff, title="MA 20", offset=0)
plot(sma(close, 30), color=#247aff, title="MA 30", offset=0)
plot(sma(close, 50), color=#00E676, title="MA 50", offset=0)
plot(sma(close, 100), color=#f85245, title="MA 100", offset=0)
plot(sma(close, 150), color=#6d60ff, title="MA 150", offset=0)
plot(sma(close, 200), color=#b4a346, title="MA 200", offset=0)
plot(sma(close, 250), color=#bc98ff, title="MA 250", offset=0)
plot(sma(close, 850), color=#c1436e, title="MA 850", offset=0)

================================================================
END OF COLLECTION